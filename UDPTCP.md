TCP首部内含原端口号和目的端口号，port解决的是端口问题。IP首部内含原IP和目的IP，IP解决的是地址问题。TCP\IP能够解决网络定位问题

TCP\IP五元组

端口号范围划分：0-1023“知名端口，被广为使用的应用层协议绑定，是固定的。

1024-65535：普通端口号

pidof 进程名可以得到该进程对应的pid。

pidof 进程名 | xargs kill -9：xargs的作用：将管道的内容放到后接的命令后面

### UDP

#### 1. 报头

1. 解包：固定报头，直接提取前8字节，剩下的向上交付
2. 报头就是一个结构化数据对象

![image-20230923171718743](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202309231717752.png)

#### 2.UDP特点

* 无连接
* 不可靠：UDP在传输层交付給下层就不关心了，即掉包后没有反应。
* 面向数据报：給多少发多少。sendto 几次recvfrom几次。相比于：TCP可能发了很多次，而接收要根据应用层实现。
* 

### 3.TCP缓冲区

1. server和client双方都有接收缓冲区和发送缓冲区，因此是全双工的
2. 缓冲区使得上层应用层的send/write函数调用完直接返回，不用阻塞。因为该函数直接将数据拷贝到传输层的发送缓冲区中，拷贝完直接返回，函数不关心数据的发送。数据的发送由OS的传输层控制，因此TCP协议有被称为传输控制协议。

## TCP协议

1. 认识TCP协议的报头。在tcp协议中，先读取20个字节，前20字节为标准报头。前20个字节中内含4位**首部长度**，范围为[0000,1111]即[0,15]。然而实际报头大小是用4位首部长度*4字节即[0,60]。例如对方发送过来的是标准报头，那么四位首部长度应该填写的是{0101}-5。
2. 读取到前20个字节后，拿到4位首部长度，通过计算将大于20字节的部分设定为选项后续读取。而把报头读取完毕，剩下的部分就是有效载荷了，将有效载荷拷贝到接收缓冲区中。报头中没有有效载荷的大小，因为tcp协议是面向字节流的，它只需要将有效载荷部分放到接收缓冲区中即可，剩下的由应用层处理。
3. 在tcp报头中内就含有目的端口号，就可以将有效载荷交给该端口号对应的进程。
4. 收到报文后如何快速找到bind该目的端口号的进程呢？OS不仅以链表的形式去维护进程的PCB（链表的优势：利于管理），也会以哈希表的形式去维护。在进程bindport的时候，会将进程填充入port对应的哈希表。当传输层收到tcp报文时，取下报头，报头内含目的端口号，拿着端口号去到管理进程的hash结构中找到对应的进程pcb，然后将有效载荷交给对应进程。
5. 进程的pcb需要维护其文件描述符表，在进程pcb中能找到struct file*，该指针指向文件描述符表，而表内的文件指针指向其管理的文件。文件内部都有字节维护的缓冲区。因此传输层直接找到文件，将有效载荷拷贝到文件的缓冲区中。
6. Linux内核是用c语言写的，因此tcp报头本质上是一个结构体
7. tcp的可靠性以及传送效率。内存和外设之间连接的线称为IO总线。内存和CPU连接的线称为系统总线。外设之间通信时，也具有自己的协议。而网络传输过程中，会出现丢包、乱序、重复等不可靠问题，那么tcp的可靠性就围绕着解决这些问题展开。
8. 没有绝对的通信可靠性。client向server发信息，client无法保证该信息server收到，因此server需要回复client一个响应，该响应可以确保client給server发送的信息收到了。但server发送給client的响应也无法保证client收到，除非client能回复server。因此信息的可靠性针对的是历史信息，而最新的消息是无法保证可靠性的。
9. 序号保持了client和server双方信息朝向的可靠性
10. 双方通信时，其通信的信息会包含正常的数据段，也会包含确认数据段，但只需要对正常数据段进行应答。
11. tcp报头中有序号和确认序号。序号标识发送出去的信息。由于tcp协议是无状态的，因此需要序号标定状态和连续性。当收到报文时，需要去查询报头的序号，然后响应信息中包含确认序号。例如服务器收到客户端发送来的报文序号是10，那么发送回去的响应的确认序号是11，表示11之前的序号的报文接收成功，且确认序号需要要求是连续的。例如客户端发送給服务器三条信息，依次序号是10，11，12，但序号11标定的信息掉包了导致服务器没有收到，因此服务器响应信息的确认序号只能是11，12。
12. tcp协议是全双工的，因此需要两组序号来保证信息朝向的可靠性。数据对于接收方而言数据乱序是一种不可靠的表现，要通过序号来对数据进行排序，保证数据的按序到达。
13. tcp协议的报头的16位窗口大小表示当前的接收缓冲区大小。对方发送数据速度过快，我方处理数据过慢会导致接收缓冲区满了继续接收数据，造成数据丢弃问题。而对方发送数据过慢会导致双方通信时间过长，因此要告诉对方我方的接收缓冲区大小，用来控制流量大小。
14. 6个标记位表示报文的类型。syn请求标记位，fin断开标记位。ack确认标记位。psh催促标记位。 催促对方尽快去拿走缓冲区里的数据，好腾出空间来让其他写入。URG紧急标志位。若发送过来的报头的URG标志位为1，说明该报文携带需要被尽快处理的数据。而16位紧急指针为该需要被紧急处理的数据的偏移量。该数据大小只能为1字节。当收到报文时，会优先去读取该数据，而管理该数据的方法独立于TCP协议的。（out-of-band通常不会使用）。RST复位标记位。双方通信时单方面出现掉线问题，当掉线一方重启后，会认为没有与其他其他建立连接，而另一方并不知道对方掉线，因此继续认为对方还在连接，继续給对方发数据。当出现这样的差错时，掉线一方会給另一方发送RST标志位为1的报文，重置连接。
15. 发送的内容以char outbuffer方式存在，数据的每一个字节都有序号，那么可以统计到有效数据的末尾即为有效数据的大小。然后该有效数据加上报头就是报文了。将该大小置进报头的序号中，告诉对方该有效载荷的大小。
16. 重传：客户端像服务器发送请求，由于某种原因造成服务器没有收到该请求即丢包，另一种场景服务器收到了请求但隔了很长时间没有响应或者响应丢包了，客户端再次发送同样的请求給服务器，这次服务器可能会再次收到相同的请求，即重传了，这也是不可靠的一种。因此要用根据序号用set进行去重。
17. 超时重传设定的时间间隔按照网络变动调整的。





### 再谈三次握手

1. 一次握手就连接建立成功的话，很容易导致恶意客户端多次向服务器发送syn请求建立多个连接导致服务器再也无法与其它需要建立连接的客户端通信，即容易造成syn洪水问题。
2. 两次握手就建立成功的话，当客户端发送出syn请求时保证了客户端建立好了连接，服务器发送了ACK+syn响应时保证了服务器建立好了连接，其原理跟一次握手无太大差异，也容易造成syn洪水问题。
3. 三次握手能够保证：

* 客户端能够发送请求，然后能够接收到服务器发送的响应，即保证了客户端具备了发、收的能力。
* 服务器接收到了客户端的第一次syn请求，接收到了客户端第二次ack，即保证了服务器也具备了发、收的能力。
* 客户端和服务器都具备了发送数据、接收数据的能力，才能保证tcp连接是全双工的。
* 客户端先向服务器发送连接请求，那么就要求客户端先确保能够建立好连接，即优先确保客户端具备发送数据、接收数据的能力。服务器被客户端连接，就要求服务器需要在客户端确保能够建立连接之后确保建立好连接。
* 三次握手是以最小陈本验证全双工通信信道是通畅的。
* 服务器受到攻击，而三次握手是用来保证双工建立好连接的，并不能解决受到攻击问题。

### 再谈四次挥手

* 连接需要双方确认，因此断开连接也需要双方确认。
* 第一次挥手是客户端向服务器发送fin断开连接请求，服务器响应一个ack表示该fin请求生效。服务器向客户端发送fin断开请求，客户端响应一个ack确保上一个fin请求生效。

三次握手和四次挥手并不是直接保证。。。。状态结构体--time_wait...



MSL：单向传输最大用时单位

断开连接的一方保持time_wait时间要是2*msl，其原因在于确保即使对方没有受到ack也有足够的时间发送fin使我方收到。另一个原因是使得历史的滞留的报文消散。 