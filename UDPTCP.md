TCP首部内含原端口号和目的端口号，port解决的是端口问题。IP首部内含原IP和目的IP，IP解决的是地址问题。TCP\IP能够解决网络定位问题

TCP\IP五元组

端口号范围划分：0-1023“知名端口，被广为使用的应用层协议绑定，是固定的。

1024-65535：普通端口号

pidof 进程名可以得到该进程对应的pid。

pidof 进程名 | xargs kill -9：xargs的作用：将管道的内容放到后接的命令后面

### UDP

#### 1. 报头

1. 解包：固定报头，直接提取前8字节，剩下的向上交付
2. 报头就是一个结构化数据对象

![image-20230923171718743](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202309231717752.png)

#### 2.UDP特点

* 无连接
* 不可靠：UDP在传输层交付給下层就不关系了，即掉包后没有反应。
* 面向数据报：給多少发多少。sendto 几次recvfrom几次。相比于：TCP可能发了很多次，而接收要根据应用层实现。
* 

### 3.TCP缓冲区

1. server和client双方都有接收缓冲区和发送缓冲区，因此是全双工的
2. 缓冲区使得上层应用层的send/write函数调用完直接返回，不用阻塞。因为该函数直接将数据拷贝到传输层的发送缓冲区中，拷贝完直接返回，函数不关心数据的发送。数据的发送由OS的传输层控制，因此TCP协议有被称为传输控制协议。

## TCP协议

1. 认识TCP协议的报头。在tcp协议中，先读取20个字节，前20字节为标准报头。前20个字节中内含4位**首部长度**，范围为[0000,1111]即[0,15]。然而实际报头大小是用4位首部长度*4字节即[0,60]。例如对方发送过来的是标准报头，那么四位首部长度应该填写的是{0101}-5。
2. 读取到前20个字节后，拿到4位首部长度，通过计算将大于20字节的部分设定为选项后续读取。而把报头读取完毕，剩下的部分就是有效载荷了，将有效载荷拷贝到接收缓冲区中。报头中没有有效载荷的大小，因为tcp协议是面向字节流的，它只需要将有效载荷部分放到接收缓冲区中即可，剩下的由应用层处理。
3. 在tcp报头中内就含有目的端口号，就可以将有效载荷交给该端口号对应的进程。
4. 收到报文后如何快速找到bind该目的端口号的进程呢？OS不仅以链表的形式去维护进程的PCB（链表的优势：利于管理），也会以哈希表的形式去维护。在进程bindport的时候，会将进程填充入port对应的哈希表。当传输层收到tcp报文时，取下报头，报头内含目的端口号，拿着端口号去到管理进程的hash结构中找到对应的进程pcb，然后将有效载荷交给对应进程。
5. 进程的pcb需要维护其文件描述符表，在进程pcb中能找到struct file*，该指针指向文件描述符表，而表内的文件指针指向其管理的文件。文件内部都有字节维护的缓冲区。因此传输层直接找到文件，将有效载荷拷贝到文件的缓冲区中。
6. Linux内核是用c语言写的，因此tcp报头本质上是一个结构体
7. tcp的可靠性以及传送效率。内存和外设之间连接的线称为IO总线。内存和CPU连接的线称为系统总线。外设之间通信时，也具有自己的协议。而网络传输过程中，会出现丢包、乱序、重复等不可靠问题，那么tcp的可靠性就围绕着解决这些问题展开。
8. 没有绝对的通信可靠性。client向server发信息，client无法保证该信息server收到，因此server需要回复client一个响应，该响应可以确保client給server发送的信息收到了。但server发送給client的响应也无法保证client收到，除非client能回复server。因此信息的可靠性针对的是历史信息，而最新的消息是无法保证可靠性的。