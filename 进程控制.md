# 进程控制

## 浅谈fork

fork函数可以从一个已存在的进程创建出一个新的进程。新进程为子进程，而原进程为父进程。

```cpp
#include<unistd.h>
pid_t fork(void);//pid_t为返回值
返回值：fork成功就把子进程pid返回给父进程，而把0返回给子进程，如果fork失败就把-1返回给父进程，子进程没有返回值
```

进程调用fork，

内核首先分配新的内存块和内核数据结构给子进程，将父进程部分数据结构拷贝给子进程，然后添加子进程到系统进程列表中，fork返回，开始调度器调度。

![image-20230116224347288](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301162243256.png)

fork之后，父子进程谁先执行完全由调度器决定。

### 写时拷贝

通常，父子进程代码共享，物理空间也是使用同一块，但任何一个进程尝试写入，操作系统先进行进程数据拷贝，让不同的进程数据进行分离，更改页表映射，然后再让进程进行修改—写实拷贝。

![image-20230116225424560](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301162254363.png)

### fork调用失败的原因

**原因：系统中有太多的进程；实际用户的进程数超过了限制呀**

这里有一段代码，运行后可以看到自己的操作系统最多可以容纳多少进程数。如果有虚拟机或者有云服务器的小伙伴可以试试噢，系统崩溃后退出系统等一会重启就好

```cpp
  1 #include<stdio.h>
  2 #include<unistd.h>
  3 
  4 int main()
  5 {
  6   int num=0;
  7   while(1)          
  8   {
  9     int ret=fork();
 10     if(ret<0)//如果创建子进程失败
 11     {         
 12       printf("fork error!,%d \n",num);
 13       break;
 14     }                
 15     else if(ret==0)                
 16     {  
 17       //子进程                          
 18       while(1)
 19       sleep(1);
 20 
 21     }
 22     //父进程
 23     num++;
 24   }
 25   return 0;
 26 }  
```

## 进程终止

咱们写c++或者c代码时，大多数从main函数开始写写写，然后写完了就return 0；那么这个return 0有啥意义呢？所谓的return 0这个0就是进程退出码，退出码记录着进程退出的结果等等

### 进程退出的场景

进程退出的场景无非就三种

**代码运行完毕，结果正确**

**代码运行完毕，结果不正确**

**代码运行异常终止了**

那么当代码运行完毕后，结果在哪可以看到呢？

### 进程常见退出方法

#### 查看进程退出码

##### echo $? :查看进程退出码

首先我写了这段代码，如果num等于5050那么main函数的进程退出码就是1，否则是0

![image-20230116234115423](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301162341472.png)

然后运行后，第一次echo $?查看到就是mytest.c的main函数进程的退出码1.而echo $?也是进程，退出码是0，那么为什么后者进程的退出码是0呢？

![image-20230116234556398](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301162345300.png)

<font size=4 color="red">**return 0这个0标识着代码跑完了，进程执行的结果正确，而非0标识代码跑完了，结果不正确！**</font>

 而！0里面不同的数字标识着不同的错误

这里要提到一个函数 strerror，该函数可以把进程退出码转化成相应的可以概括结果的字符串；然后这里我写一个小程序打印200以内的进程退出码对应的结果的字符串概括

![image-20230116235737464](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301162357607.png)

我把结果拷贝到下面了，可以看到Linux系统下一共有134种进程退出码，每一个退出码都有对应的结果。其中第一种0代表着进程执行的结果正确，而其他都是进程执行的结果错误对应的原因。

```cpp
0: Success
 1: Operation not permitted
 2: No such file or directory
 3: No such process
 4: Interrupted system call
 5: Input/output error
 6: No such device or address
 7: Argument list too long
 8: Exec format error
 9: Bad file descriptor
 10: No child processes
 11: Resource temporarily unavailable
 12: Cannot allocate memory
 13: Permission denied
 14: Bad address
 15: Block device required
 16: Device or resource busy
 17: File exists
 18: Invalid cross-device link
 19: No such device
 20: Not a directory
 21: Is a directory
 22: Invalid argument
 23: Too many open files in system
 24: Too many open files
 25: Inappropriate ioctl for device
 26: Text file busy
 27: File too large
 28: No space left on device
 29: Illegal seek
 30: Read-only file system
 31: Too many links
 32: Broken pipe
 33: Numerical argument out of domain
 34: Numerical result out of range
 35: Resource deadlock avoided
 36: File name too long
 37: No locks available
 38: Function not implemented
 39: Directory not empty
 40: Too many levels of symbolic links
 41: Unknown error 41
 42: No message of desired type
 43: Identifier removed
 44: Channel number out of range
 45: Level 2 not synchronized
 46: Level 3 halted
 47: Level 3 reset
 48: Link number out of range
 49: Protocol driver not attached
 50: No CSI structure available
 51: Level 2 halted
 52: Invalid exchange
 53: Invalid request descriptor
 54: Exchange full
 55: No anode
 56: Invalid request code
 57: Invalid slot
 58: Unknown error 58
 59: Bad font file format
 60: Device not a stream
 61: No data available
 62: Timer expired
 63: Out of streams resources
 64: Machine is not on the network
 65: Package not installed
 66: Object is remote
 67: Link has been severed
 68: Advertise error
 69: Srmount error
 70: Communication error on send
 71: Protocol error
 72: Multihop attempted
 73: RFS specific error
 74: Bad message
 75: Value too large for defined data type
 76: Name not unique on network
 77: File descriptor in bad state
 78: Remote address changed
 79: Can not access a needed shared library
 80: Accessing a corrupted shared library
 81: .lib section in a.out corrupted
 82: Attempting to link in too many shared libraries
 83: Cannot exec a shared library directly
 84: Invalid or incomplete multibyte or wide character
 85: Interrupted system call should be restarted
 86: Streams pipe error
 87: Too many users
 88: Socket operation on non-socket
 89: Destination address required
 90: Message too long
 91: Protocol wrong type for socket
 92: Protocol not available
 93: Protocol not supported
 94: Socket type not supported
 95: Operation not supported
 96: Protocol family not supported
 97: Address family not supported by protocol
 98: Address already in use
 99: Cannot assign requested address
 100: Network is down
 101: Network is unreachable
 102: Network dropped connection on reset
 103: Software caused connection abort
 104: Connection reset by peer
 105: No buffer space available
 106: Transport endpoint is already connected
 107: Transport endpoint is not connected
 108: Cannot send after transport endpoint shutdown
 109: Too many references: cannot splice
 110: Connection timed out
 111: Connection refused
 112: Host is down
 113: No route to host
 114: Operation already in progress
 115: Operation now in progress
 116: Stale file handle
 117: Structure needs cleaning
 118: Not a XENIX named type file
 119: No XENIX semaphores available
 120: Is a named type file
 121: Remote I/O error
 122: Disk quota exceeded
 123: No medium found
 124: Wrong medium type
 125: Operation canceled
 126: Required key not available
 127: Key has expired
 128: Key has been revoked
 129: Key was rejected by service
 130: Owner died
 131: State not recoverable
 132: Operation not possible due to RF-kill
 133: Memory page has hardware error
 134: Unknown error 134
 135: Unknown error 135
 136: Unknown error 136
 137: Unknown error 137

```

一般情况下，进程正常终止，要么是main函数返回（别的函数返回为函数调用结束）；调用exit；系统调用_exit；

##### exit和_exit

<font size=4 color="red">**exit:调用这个函数后可以让进程直接退出 ，参数为进程退出码**</font>

![image-20230117102637450](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171026261.png)

然后我写了这么一个代码，如果main函数没退出则进入死循环。

![image-20230117103056504](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171030146.png)

那么运行后查看看到main函数确实是退出了

![image-20230117103227709](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171032120.png)

然后我再写这段代码，一般情况下其他函数结束为函数调用结束，而我在这个addtosum函数这里在返回值前面调用了个exit函数，**看它是退出函数调用还是退出进程。**

![image-20230117104200445](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171042561.png)

事实证明exit函数在任意函数调用都是直接退出进程！

![image-20230117104257884](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171043391.png)

exit是库函数，而_exit是系统调用，那么exit的底层实现也是 _exit，那么exit和 _exit有什么区别呢？

写了这段代码

![image-20230117105010830](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171050757.png)

运行后可以看到两秒后hello bug打印出来了

![image-20230117105101479](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171051629.png)

那么把exit改成_exit呢？

![image-20230117105147945](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171051059.png)

可以看到压根就没打印出来

![image-20230117105209120](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171052242.png)

这个对比可以知道，库函数的exit和系统调用的_eixt的区别是：<font size=4 color="red">**exit在退出进程前会刷新缓冲区，而 _exit则不会。**</font>并且可以推断出缓冲区不在操作系统中，应该在用户空间里。

![image-20230117111351231](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171113227.png)

## 进程等待

如果子进程退出，父进程对该进程不管不顾，那么就可能造成僵尸进程问题，进而导致内存泄露。另外进程一旦变成了僵尸进程，就连杀死进程的指令kill -9都无能为力。那么父进程应该怎么管理退出的子进程呢？

<font size=4 color="purple">**子进程运行完成后，父进程要通过进程等待的方式：回收子进程资源，获取子进程退出信息**</font>，这样过后就避免了僵尸进程的出现。

### 进程等待的方法

#### wait

父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。

第一个函数的参数为*status,是一个整数类型的指针，**大多数情况都传NULL，如果成功就返回被收集子进程的pid，如果失败就返回-1**

![image-20230117113954135](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171139254.png)

 然后我写了这样的函数，创建了一个子进程，进到子进程里面打印子进程pid和父进程ppid，然后睡眠一秒，五秒后子进程退出，但由于父进程也睡眠了，所以会进入僵尸状态，之后几秒后父进程回收子进程并打印出wait的返回值

![image-20230117120944756](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171209071.png)

运行后看到确实如此

![image-20230117121622756](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171216004.png)

#### waitpid

我写了这么一段代码，ret获取到子进程的pid，stastus获取到子进程的退出信息。

![image-20230117154241534](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171542620.png)

那么status到底是啥呢？

![image-20230117154410721](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301171544731.png)

### 获取子进程status

1.wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充；如果传递NULL，表示不关心子进程的退出状态信息；否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程。

2.**status不能简单的当作整形来看待，可以当作位图来看待，即status要都能表示进程退出时的三种场景。**（代码运行完毕，结果正确；代码运行完毕，结果不正确；代码运行异常终止了）

整数status的二进制下有32个比特位，现在先看前16个比特位（0-15）；

<font size=5 color="red">**第8-15个比特位（次低八位）存放进程的退出状态即子进程的退出码（通过退出状态得知进程运行完结果是否正确）退出码为0则结果正确。非0则对应错误的情况**。</font>

![image-20230118215443955](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301182154725.png)

<font size=5 color="red">**第0-6位（低七位）存放进程的终止信号（通过终止信号得知进程是否正常退出），第8位存放core dump标志（如图：status的二进制结构），终止信号为0—进程正常退出。非0为异常，通过kill -l可以看到大部分终止信号的情况。**</font>

![image-20230118211643871](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301182116663.png)

**通过status&0x7F[01111111]得到终止信号**，                                                  **再通过（status>>8)&0xFF[011111111]得到退出码**

![image-20230118220654591](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301182206771.png)

![image-20230118220728630](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301182207650.png)

相应的，通过kill杀死子进程也可以获取到相应的终止信号

比如我对子进程kill -3，那么子进程返回父进程的终止信号也是3

![image-20230118223901470](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301182239940.png)

#### 再谈僵尸进程

当子进程退出时，会把代码和数据释放掉，但是退出信息（退出码和退出信号）要存在子进程的pcb中，此时子进程为Z状态，当父进程系统调用waitpid时，父进程会通过子进程id从子进程pcb中拿退出信息到status里。

![image-20230118222011229](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301182220163.png)



