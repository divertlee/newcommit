# 继承

## 继承的概念

继承(inheritance)机制是面向对象程序设计使代码可以复用的重要手段，它允许程序员**在保持原有类特性的基础上进行扩展，这样产生新的类，称派生类。**继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，**继承是类设计层次的复用**。

## 继承的定义

![image-20230114165416378](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141654416.png)

实例代码，写了一个Person的类，然后一个Teacher和一个Student的类通过public继承它

```cpp
class Person
{
public:
	void Print()
	{
		cout << "name: " << _name << endl;
		cout << "age: " << _age << endl;
	}
private:
	string _name = "pjl";
	int _age = 18;
};
class Student:public Person
{
protected:
	int studnum;//学号
};

class Teacher:public Person
{
protected:
	int _teachnum;//教师学号
};

int main()
{
	Student st;
	Teacher te;
	st.Print();
	te.Print();
	return 0;
}
```

通过调试可以看到子类Student、Teacher可以继承到父类Person的public成员，并且在对象里面有父类的private成员

![image-20230114170047528](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141700519.png)

![image-20230114170504760](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141705674.png)

那么具体的继承方式是怎么样的呢？

#### 继承方式和访问限定符

![image-20230114171102999](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141711968.png)

![image-20230114171159252](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141712100.png)

##### 继承基类成员访问方式的变化

| 类成员/继承方式         | public继承                | protected继承             | private继承             |
| ----------------------- | ------------------------- | ------------------------- | ----------------------- |
| **基类的public成员**    | **派生类的public成员**    | **派生类的protected成员** | **派生类的private成员** |
| **基类的protected成员** | **派生类的protected成员** | **派生类的protected成员** | **派生类的private成员** |
| **基类的private成员**   | **在派生类中不可见**      | **在派生类中不可见**      | **在派生类中不可见**    |

咋理解呢？

1.基类的public成员，派生类public继承那么就是public成员，protected继承就是protected成员，private继承就是private成员，以此类推。<font size=4 color="blue">**即取基类的成员访问限定符和派生类继承方式取小的那一个。**</font>

2.但是一个特殊的地方：<font size=4 color="red">**基类的private成员，在派生类是不可见的，即基类的private成员还是被继承到了派生类对象中，但语法上限制派生类对象无论在类中还是类外都不能去访问它！** </font>如果基类想要自己的private成员不在类外被访问，但可以在派生类中访问就定义成员为protected。这也可以看出**保护成员限定符是因继承才出现的。**

3.使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过最好显示的写出继承方式。

![image-20230114182619262](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141826177.png)

## 基类和派生类对象赋值转换

1.**派生类对象** 可以赋值给 **基类的对象** / **基类的指针** / **基类的引用**。这里有个形象的说法叫切片或者切割。寓意把<font size=4 color="red">**派生类中父类那部分切来赋值过去**。</font>

![image-20230114190333313](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141903540.png)

![image-20230114190742010](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141907304.png)

![image-20230114190909622](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141909578.png)

## 继承中的作用域

1. **在继承体系中基类和派生类都有独立的作用域。**
2. 子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。（**在子类成员函数中，可以使用 基类::基类成员 显示访问**）
3. 需要注意的是如果是成员函数的隐藏，<font size=4 color="red">**只需要函数名相同**</font>就构成隐藏。

可以看到这里类B的fun函数是带参的，那么调用带参的自然就是类B的，那如果直接调用不带参的呢？会不会直接是类A的呢？

![image-20230114192915528](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141929541.png)

可以看到报错了，类B和类A的fun函数函数名相同就构成隐藏/重定义，所以需要显示访问！

![image-20230114192948402](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141929529.png)

![image-20230114193016057](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301141930951.png)

## 派生类的默认成员函数

### 构造函数

<font size=4 color="red">**派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。**</font>

我写了一个Person类和Student类，Person类是Student的父类；里面都有构造、拷贝构造、赋值重载、析构函数。

然后一个简单的调用子类。

![image-20230114211841436](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301142118628.png)

现在我把**子类构造函数的初始化列表注释掉，可以看到子类构造函数调用了父类的构造函数。**

![image-20230114211645334](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301142116516.png)

如果基类没有默认的构造函数（基类自身没有写构造函数，编译器才会产生默认构造函数），派生类构造函数的初始化列表阶段显示调用。

![image-20230114214136942](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301142141026.png)

### 拷贝构造

派生类继承基类的那部分成员必须要必须调用基类的拷贝构造完成基类的拷贝初始化，其余的部分调用派生类的拷贝构造即可。

![image-20230114215129022](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301142151133.png)

### 赋值重载

派生类继承基类那部分成员必须必须要调用基类的operator=完成基类的复制，其他部分调用派生类自身的赋值重载。

![image-20230114215600171](https://non1.oss-cn-guangzhou.aliyuncs.com/write1/202301142156042.png)